\subsubsection{Job Queue}
When analyzing thousands of sound files, it becomes necessary to set up a queue. This allows researchers to set up jobs to process in the future after current jobs are done processing. In the same vein, the job queue allows the server to process jobs while still listening to incoming requests. This gives our server the ability to handle concurrent requests without crashing.\par 
Our queue is run using the \codesnip{bull} package. Using the Redis caching server, \codesnip{bull} spins up JavaScript subprocess. These subprocesses allow job processing do be performed independent of the main JavaScript event loop. This frees up the main loop to handle server requests and additions of new jobs to the queue.\par
Once a job is added to the queue it goes through several changes in its \codesnip{status}, starting with a brief \codesnip{waiting} status, which indicates that it is about to go into the queue. Once added, the job\textquotesingle s \codesnip{status} becomes \codesnip{queued}, which places it in the job queue. From there, it will wait for its turn in the queue, finally changing to \codesnip{processing}, sending it to the job processor which runs the analysis. Once in this state, the job can either fail, giving a \codesnip{failed} status, or it can succeed with a \codesnip{completed} status.\par
Each change in a job\textquotesingle s \codesnip{status} is relayed to the database, allowing us to handle random server failures. In case of such failure, when the server starts back up, it scans for jobs that were in the \codesnip{waiting}, \codesnip{queued}, or \codesnip{processing} statuses. It restarts these jobs so the user can pick up right were they left off in case of a crash.