\subsection{Design Iterations}

\paragraph{Shiny Application} \mbox{}\\[\paragraphheaderspace]
Our first idea was to create the application using the R package Shiny. Shiny apps are written in R and support reactive data visualisation. Shiny also allows Javascript, HTML and CSS to be added. We liked the idea of writing most of our app in R since our project needs to use the \codesnip{soundecology} R package for data analysis.\par
We read the documentation on Shiny and watched some video tutorials. Josh also made a Shiny demo that used the \codesnip{soundecology} package to analyze a sample sound file. This demo helped us understand the way the data analysis will interact with the frontend visualizations. Sound ecologists may want to run the R algorithms with different parameters on the same file to produce different types of results. This demo led to the realization that since the data analysis of multiple files will take some time to finish, we would not be able to let users change parameters and see immediate results. This type of reactivity seemed to be one of the most impressive features of Shiny, but it would not be of much use to us. Based on this, we came up with the idea of a job queue for file analysis and we are still planning on creating this feature.\par
During this time we also decided that D3.js would be a great option for data visualization. This library has a lot of interesting options for interactive visualizations that are more impressive than what is supported by Shiny, in our opinion. With D3 custom visualizations can be made and different types of heat maps are included that we would like to implement in our project. D3 still may be used in some capacity in this project, however Recharts has been used primarily.\par

\paragraph{Serverless Architecture} \mbox{}\\[\paragraphheaderspace]
Around this time, we began to think about the backend design and potential ways to speed up processing time. We started to discuss implementing a serverless architecture with AWS. We planned to use S3 to store users\textquotesingle  sound files, allowing files to be shared amongst research groups. AWS Lambda would be used to run the R algorithms. We would use Relational Database Service with MySQL for our database that would save the results of the R algorithms and other information needed for research team collaboration.\par
We do not have a budget for this project and want to make it free to promote more research, but thought the cost would be manageable for us to pay until the project could get a grant to cover the cost of these services. After running AWS cost estimation calculators we realized this would probably not be true. The cost of Lambda would be more than we thought because of the time required to run the algorithms on multiple files. In addition, the cost of storing the large number of sound files generally analyzed in this type of research in S3 was a bit substantial, so we started to think of a different design.\par

\paragraph{Options for Processing} \mbox{}\\[\paragraphheaderspace]
We further considered the benefits and downfalls of having the application hosted on a local server verses online. Eventually, we decided it would be best to offer both options to the user. The user could run the application locally for free, but the analysis would take longer to complete. We would also have a paid version, where the user could speed up this process by using AWS Lambda. Both of these options would be offered on a desktop application, this is when we started to look into using Electron which would allow the application to be cross-platform.\par
After looking at the data types of the outputs of the \codesnip{soundecology} R algorithms, we decided that a non-relational database would work better for our project. After agreeing on MongoDB for the locally run version, we discussed doing a MERN stack application with Electron. Our team has more experience with the these technologies, so less time will be required for new learning. Installing and setting up MongoDB locally will have to be handled in our installer. We are looking into the best way to do this, such as installers provided by Electron.\par
The paid version will use the AWS technologies discussed in Serverless Architecture, apart from RDS. This feature will use DynamoDB instead, since our data will be non-relational.\par
The collaboration aspect of our project would be hosted on a web application, apart from the desktop application. While the desktop application would be used for analysis and data visualization, the web application would only be used to upload the results of analyses performed on the desktop application to a user\textquotesingle s research group. This would let users see visualizations of analysis jobs performed by other researchers, without having to analyze those files on the desktop application.\par

\paragraph{Collaboration on Electron App} \mbox{}\\[\paragraphheaderspace]
During the next step of the design, we considered if a separate web application would be necessary. We decided it would be a better idea to include the collaboration features and analysis tools all together in the Electron app. Putting these features together could be accomplished by uploading collaborative data to DynamoDB instead of a user\textquotesingle s local Mongo database. This would put all of the features of the project in one place and still give users options on which ones would be useful to their research.\par

\paragraph{Modularity} \mbox{}\\[\paragraphheaderspace]
After a meeting with our sponsor, we realized the importance of researchers having access to a research group\textquotesingle s files. Sharing data visualizations would not be as valuable to researchers without also sharing the files that produced the results. In our sponsor\textquotesingle s case, a very large set of audio files are stored on a QNAP, which can also act as a server. Soundscape ecology researchers elsewhere, such as Purdue University, have a similar setup. It would be beneficial to research groups to be able to access each other\textquotesingle s files. As we have already ruled out using AWS S3 for file storage, we began to think of other options.\par
We considered adding functionality for server admins to share account credentials with research groups. This would grant users access to a remote server directly and permit downloading any sound files stored there. However, downloading large sets of 10 minute audio files would still require a lot of time. We would like to avoid this since running the \codesnip{soundecology} algorithms will already involve a lot of waiting for the user.\par
We started to look into the idea of a modular application in which the sound processing could be handled on the remote servers that many university researchers can access. Handling processing on the same server which stores files would be much faster than having a user connect and download files from the server to perform analysis locally. These servers would also host a database to enable group collaboration. This database will store account information of all users in that research group and admin status. All analysis data obtained by all group members will also be stored here, permitting users to view data visualizations of files they have access to without having to wait for files to be processed with R.\par
An AWS DynamoDB database will store user permissions for accessing other servers and credentials to connect to them. The server admin will be responsible for providing the account credentials, along with determining which users can access them.\par
The option to run the backend processing and a MongoDB database on a local machine will still be available. When using this configuration, a user will be able to upload their locally stored analysis results to DynamoDB to promote collaboration.\par
The frontend Electron application will be used with both options for processing. This application will provide the user interface for creating jobs, data visualization and admin management of server permissions. With this iteration, we discussed using Redux.js with React. This would enable states of our application to be managed in a more unified and clear way than React provides. Data like a user\textquotesingle s logged in status will need to be accessed in multiple components of the user interface and Redux will make important data like this accessable within any React component. Most of our group is inexperienced with this technology, so it will require some time to learn.\par

\paragraph{UI Additions} \mbox{}\\[\paragraphheaderspace]
While discussing our database design, we discussed how we will handle the case of a user moving files to different directory than what is stored in the database. Instead of just showing the user an error message when the file cannot be found, we decided to use a working directory feature. The user will select a working directory which contains the files they would like to analyze. This approach will allow us to only store file names in our database without file path. This approach will prevent incorrect file paths from being saved if they are moved by the user.\par
Another feature we have decided to include is letting the user save sets of parameter values that they commonly use. This feature will be useful to researchers because depending on which sets of parameters are used with sound files, the outcomes of the \codesnip{soundecology} indices can produce different types of meaningful results. Users will be able to give a set of parameters an alias or tag so it can be easily identified, otherwise a name based on the date that preset was first used will be assigned. When creating a new job, the user will see the chosen names of all the preset parameters listed for each index, or the ability to create a new set.\par
A status will also be assigned to each job to inform the user of what is going on. These statuses include queued, processing, finished and failed. Jobs will be queued if they have not started processing yet. Processing will be assigned to jobs currently running. The finished status is assigned after the job is complete, or failed if an error caused the job to stop processing before it was completed. Users will be able to filter jobs based on this, such as seeing a list of all jobs that are currently processing or all completed jobs.\par

\paragraph{Changes in Database Design} \mbox{}\\[\paragraphheaderspace]
Improvements have been made to the structure of our MongoDB database. In previous iterations, we planned to have separate and unique collections for the jobs, specifications, and inputs for each of the indices. We have since found a way to simplify this design after discovering Mongoose\textquotesingle s documentation on what they call ``discriminators.'' Discriminators permit adding inheritance to Mongoose models, allowing multiple schemas to map to the same Mongo collection while simultaneously allowing for variability between those models. This is helpful in our project due to the slight differences in things like job specification parameters among the indices. With this method, we can define schemas for the parameters of each index and still have the benefits of Mongoose validation for each one, all while storing each type of data in a single collection. The only additional constraint is a string field for the index related to the type of data added for querying specific types of jobs and parameters.\par
Other changes to the database structure is that the results of jobs will be added to the same document that is made on creation for the jobs themselves. When a job is created, the value of a job\textquotesingle s result is set to null, to be updated after the job has finished processing.\par

\paragraph{UI Framework} \mbox{}\\[\paragraphheaderspace]
We have decided to use Material-UI for styling the client application. Material-UI is specific to React and uses predefined React components instead of only class names like some other popular CSS frameworks. This framework provides many components that will be useful in our application, like the Stepper component for the job creation page. Adding these UI features with Material-UI will be simpler than implementing all of it ourselves. Our team also is unified in liking the styles Material-UI provides and think it is a good start for the styling conventions we will use. This framework will also help ensure that the frontend team is consistent with styling throughout the client application.\par

\paragraph{API Modifications} \mbox{}\\[\paragraphheaderspace]
The backend was originally designed (prior to any attempt at implementation) so that the API would support batch operations for things like job creation. This decision was made due the nature of the software being in the business of batch processing multiple inputs with multiple specifications. However, upon initial implementation, the backend team found that the kinds of batch requests that would be made were neither supported by Express nor the HTTP standard for certain types of requests (like GET). To overcome these limitations, the backend team chose to simplify the API design to make individual operations for each request.\par
After this redesign, multiple similar API calls must be made to the server when performing certain types of user interactions. For example, when creating a batch of jobs that uses the same specification, a variation on the same request must be made for each subsequent job being created in the batch. To summarize, the iterative portion of performing batch requests on data from the server has shifted from the creation of the request body to the sending of each request. No analysis has yet been made to determine what kind of performance impact this may have on either the client or the server, but it is expected that this change will, at the very least, simplify the design process.\par
