\subsubsection{Methodologies}
There are several testing methodologies available to us. We will use a combination of several types of testing in order to ensure our entire system is fool-proof. The following four testing types will be used:

\paragraph{Unit Testing} \mbox{}\\[\paragraphheaderspace]
Unit testing involves testing the smallest piece of code that can be logically isolated from a system. This piece of code can be a function, a subroutine, or a method. This type of testing should be conducted by the programmer. This is due to the fact that unit testing should be done continuously while developing a section of code. Making it most efficient when implemented by the programmer. We will be unit testing functions and API calls that are made before adding them to the main code. This will ensure that the number of faulty methods that are introduced are minimal.\par
The reason unit testing works so well stems from the idea that a whole is just made up of smaller parts. If each of the smaller parts of a system are working then in theory the whole system should work. In practice other types of tests are needed to ensure all subsystems are working together properly, but unit testing does resolve many of the issues within the subsystems. Resolving local issues makes it much easier to debug the whole system during the final stretch of the project.

\paragraph{Integration Testing} \mbox{}\\[\paragraphheaderspace]
Integration testing involves making sure that the connections between pieces of a system are working properly. This is the area in which unit testing tends to miss bugs and where most bugs are actually found. The reason for this is that unit tests should only be used on small logically separated pieces of code. So, when different sections are joined together, the undiscovered bugs come out. Additionally, different sections are usually programmed by different developers, meaning that there may be conflicts due to unexpected outputs or unexpressed requirements for each section. This is where integration testing comes in. In order to properly perform integration testing, it becomes necessary to take a step back from the code and analyze the flow of data through the system. This allows for any logical errors to be sniffed out before running tests. After making sure that the flow of data is working as expected, it becomes possible to run automated tests that send data all the way through the system. This makes sure that all points of connection are working properly and that data is not being corrupted or changed erroneously.\par
Without integration testing at every connection point, debugging code can become very difficult. This is due to the possibility of data ``black holes,'' where data is either corrupted or completely lost somewhere in the pipeline of the system. If a system is fully built without testing each connection point, it can be almost impossible to pinpoint exactly where a black hole is happening. Therefore, our team will conduct integration tests at every connection between any two software units.

\paragraph{Functional and Data-Driven Testing} \mbox{}\\[\paragraphheaderspace]
While functional testing and data-driven testing are separate ways of performing automated testing, in our project, they will be conducted in almost an identical manner. Once the project has been built to a functional point. We will assume the role of users and gauge the experience when using the product. This is the methodology of functional testing. While usually implemented by a team of individuals, for our product, much of the experience lies in how the data is processed and displayed. This is where data-driven testing comes into play. We will pass multiple sound files and see if they match their expected outputs. If the outputs match we will then analyze the runtime and determine the clarity of the charts. This method of combining both functional testing and data-driven testing will allow us to fully view the functionality of our product from the perspective of a user.\par
During the data-driven portion of testing we will also be introducing some chaos testing to the mix. This involves running the product in several different environments, i.e. Mac, Linux and Windows. Within each of these separate environments we will also run a number of common applications a user might be running alongside our program. This will simulate real world use, allowing us to see how our product performs with, for example, fluctuating CPU and RAM usage. It will also allow us to see whether or not there are any compatibility issues with other programs which, while rare, can be detrimental to our product. Another element of chaos testing we will implement will be random shut offs and disconnections from networks during processing. This will ensure that no data is corrupted or permanently lost during these emergency events. Performing this type of testing will allow us to see that our product is robust and secure, even during complete failures of the system that is running it.

\paragraph{User Testing} \mbox{}\\[\paragraphheaderspace]
User testing has proven to be the most valuable form of testing we have done. By allowing our sponsor to actually use the software since the early stages, we have been able to identify problems very quickly and resolve them as soon as possible. While unit testing and data driven testing allow us to get scripted success in terms of testing, users will always find a way to break software through just simply using the software. The actual process of user testing in the case of Mangrove has included simply going through with the usual workflow done by our sponsor. This includes uploading inputs, running jobs on them, and then viewing the results in the Analysis View. Along the way, many API requests are both placed and received, and plenty of frontend functions must operate properly with any variable form of data from the user. It has been very important for us to ensure that the software is user proof, in that no matter what the user does incorrectly, any errors are handled in such a way that the user can still continue to use the software. These error handlers include API request failure notifications, visualization rendering error notifications, and data modeling error notifications. Without these, the client would crash and would require a full refresh to resume work, which is unacceptable.\par
Through user testing, bugs in both the backend and frontend have been found and fixed, and cross platform issues were also able to be identified and dealt with. All these fixes that came as a result of user testing were crucial to the success of Mangrove as the end of semester deadline approached.
