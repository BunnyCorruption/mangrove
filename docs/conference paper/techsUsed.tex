\begin{center}
VI. Technologies Used
\end{center}
\begin{flushleft}
\setlength{\parindent}{0.125in}
\noindent\textit{A. Client --- Electron, ReactJS, Recharts}\par
React is a JavaScript library made for creating user interface components in an easily reusable way. Each React component allows for an HTML mockup with variables that are used as placeholders into which information can be passed. React was essential because it allowed us to create HTML templates that are useable with different parameters, for quickly making new and similar pages.\par
Electron is a tool for creating desktop applications using JavaScript, HTML, and CSS. Electron includes cross platform support as well as crash reporting. These features were crucial for this project since our sponsor uses a Mac device and the development team used a variety of operating systems.\par
Recharts is the library Mangrove uses for creating the data visualizations from job results. It is built off the D3 library and offers a great API for creating easy to read, high quality graphs using React components. In addition, it offers a wide variety of graph types, many of which are essential to this project, as each index being used requires different visual representation. Recharts also allows for interactivity with the graphs themselves, so allowing the user to listen to audio files with the click of a data point is possible.\\[4pt]

\noindent\textit{B. Server --- NodeJS, Express, MongoDB, Mongoose, Redis, R}\par
Express is a JavaScript library for creating a sort of \textquotesingle skeleton\textquotesingle\ of a website\textquotesingle s. By using Express, we can create an outline of our site\textquotesingle s local backend infrastructure. This is useful for the development of the API we will be using to allow all the working pieces of the project to interact with each other.\par
Using Node and MongoDB along with Mongoose, we can interface and query the local MongoDB database. The reason that MongoDB is the best choice for our particular project is that Mongo allows for more dynamic database objects than a SQL database. An example of this would be in the output of the algorithms being run against the sound files. Some of the output is done in lists, and depending on the size of the input files, the number of those lists is arbitrary. This characteristic makes using a SQL database very difficult because we would need an arbitrary number of rows for each list that is output from the processing. With MongoDB, we can include lists as a field in our database, and there these lists can be populated in a much more compact way. In addition, during planning, we came up with an efficient way to map parameter research, which we are referring to as jobs, to the inputs they are run on. MongoDB allows reference IDs as fields, where a set of inputs, or multiple sets, will be mapped to many different jobs. This will allow the user a lot of freedom when choosing what kind of analysis they want to run on their data.\par
As for the processing of jobs on indices we used Redis. This cache server allows us to use a package by the name of \codesnip{bull}. The combination of \codesnip{bull} and Redis allow the server to run jobs outside of the JavaScript server\textquotesingle s event loop. This means that we can process multiple jobs at the same time, all the while keeping the server open to new requests. Without Redis, our server would be ``busy'' during any processing and wouldn't be able to communicate with the client.\par
For the actual processing of the jobs we used the R scripting language. We went with this choice because the \codesnip{soundecology} package is written in R. On top of that, the R language is relatively fast when compared to JavaScript. In order to bridge the gap between JavaScript and R we used the \codesnip{r-script} package. This allows us to run R scripts and retrieve their returned data. To do this we wrapped each \codesnip{soundecology} function in a wrapper script that sanitizes inputs and outputs. Once the script is run we capture the results in a JavaScript object and store it in the database. Once stored we can send the data to the client in order to be displayed.\par

\end{flushleft}
