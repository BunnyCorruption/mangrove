\subsection{Design Iterations}

\subsubsection{Shiny Application}
Our first idea was to create the application using the R package Shiny. Shiny apps are written in R and support reactive data visualisation. Shiny also allows Javascript, HTML and CSS to be added. We liked the idea of writing most of our app in R since our project needs to use the soundecology R package for data analysis.\par
We read the documentation on Shiny and watched some video tutorials. Josh also made a Shiny demo that used the soundecology package to analyze a sample sound file. This demo helped us understand the way the data analysis will interact with the frontend visualizations. Sound ecologists may want to run the R algorithms with different parameters on the same file to produce different types of results. This demo led to the realization that since the data analysis of multiple files will take some time to finish, we would not be able to let users change parameters and see immediate results. This type of reactivity seemed to be one of the most impressive features of Shiny, but it would not be of much use to us. Based on this, we came up with the idea of a job queue for file analysis and we are still planning on creating this feature.\par
During this time we also decided that D3.js would be a great option for data visualization. This library has a lot of interesting options for interactive visualizations that are more impressive than what is supported by Shiny, in our opinion. With D3 custom visualizations can be made and different types of heat maps are included that we would like to implement in out project. We are still planning on using D3.js.\par

\subsubsection{Serverless Architecture}
Around this time, we began to think about the backend design and potential ways to speed up processing time. We started to discuss implementing a serverless architecture with AWS. We planned to use S3 to store users\textquotesingle sound files, allowing files to be shared among research groups. AWS Lambda would be used to run the R algorithms. We would use Relational Database Service with MySQL for our database that would save the results of the R algorithms and other information needed for research team collaboration.\par
We do not have a budget for this project and want to make it free to promote more research, but thought the cost would be manageable for us to pay until the project could get a grant to cover the cost of these services. After running AWS cost estimation calculators we realized this would probably not be true. The cost of Lambda would be more than we thought because of the time required to run the algorithms on multiple files. In addition, the cost of storing the large number of sound files generally analyzed in this type of research in S3 was a bit substantial, so we started to think of a different design.\par

\subsubsection{Options for Processing}
We further considered the benefits and downfalls of having the application hosted on a local server verses online. Eventually, we decided it would be best to offer both options to the user. The user could run the application locally for free, but the analysis would take longer to complete. We would also have a paid version, where the user could speed up this process by using AWS Lambda. Both of these options would be offered on a desktop application, this is when we started to look into using Electron which would allow the application to be cross-platform.\par
After looking at the data types of the outputs of the soundecology R algorithms, we decided that a non-relational database would work better for our project. After agreeing on MongoDB for the locally run version, we discussed doing a MERN stack application with Electron. Our team has more experience with the these technologies, so less time will be required for new learning. Installing and setting up MongoDB locally will have to be handled in our installer. We are looking into the best way to do this, such as installers provided by Electron.\par
The paid version will use the AWS technologies discussed in iteration 2, apart from RDS. This feature will use DynamoDB instead, since our data will be non-relational.\par
The collaboration aspect of our project would be hosted on a web application, apart from the desktop application. While the desktop application would be used for analysis and data visualization, the web application would only be used to upload the results of analyses performed on the desktop application to a user\textquotesingle s research group. This would let users see visualizations of analysis jobs performed by other researchers, without having to analyze those files on the desktop application.\par

\subsubsection{Collaboration on Electron App}
During the next step of the design, we considered if a separate web application would be necessary. We decided it would be a better idea to include the collaboration features in the Electron app. Putting these features together could be accomplished by uploading collaborative data to DynamoDB instead of a user\textquotesingle s local Mongo database. This would put all of the features of the project in one place and still give users options on which ones would be useful to their research.\par

\subsubsection{Modularity}
After a meeting with our sponsor, we realized the importance of researchers having access to a research group\textquotesingle s files. Sharing data visualizations would not be as valuable to researchers without also sharing the files that produced the results. In our sponsor\textquotesingle s case, a very large set of audio files are stored on a QNAP, which can also act as a server. Soundscape ecology researchers elsewhere, such as Purdue University have a similar setup. It would be beneficial to research groups to be able to access each other\textquotesingle s files. As we have already ruled out using AWS S3 for file storage, we began to think of other options.\par
We considered adding functionality for server admins to share account credentials with research groups. This would grant users access to a remote server directly and permit downloading any sound files stored there. However, downloading large sets of 10 minute audio files would still require a lot of time. We would like to avoid this since running the soundecology algorithms will already involve a lot of waiting for the user.\par
We started to look into the idea of a modular application in which the sound processing could be handled on the remote servers that many University researchers can access. Handling processing on the same server which stores files would be much faster than having a user connect and download files from the server to perform analysis locally. These servers would also host a database to enable group collaboration. This database will store account information of all users in that research group and admin status. All analysis data obtained by all group members will also be stored here, permitting users to view data visualizations of files they have access to without having to wait for files to be processed with R.\par
An AWS DynamoDB database will store user permissions for accessing other servers and credentials to connect to them. The server admin will be responsible for providing the account credentials, along with determining which users can access them.\par
The option to run the backend processing and a MongoDB database on a local machine will still be available. When using this configuration, a user will be able to upload their locally stored analysis results to DynamoDB to promote collaboration.\par
The frontend Electron application will be used with both options for processing. This application will provide the user interface for creating jobs, data visualization and admin management of server permissions. With this iteration, we discussed using Redux.js with React. This would enable states of our application to be managed in a more unified and clear way than React provides. Data like a user\textquotesingle s logged in status will need to be accessed in multiple components of the user interface and Redux will make important data like this accessable within any React component. Most of our group is inexperienced with this technology, so it will require some time to learn.\par

\subsubsection{UI Additions}
While discussing our database design, we discussed how we will handle the case of a user moving files to different directory than what is store in the database. Instead of just showing the user an error message when  the file cannot be found, we decided to use a working working directory feature. The user will select a working directory which contains files they would like to analyize. This approach will allow us to only store file names in our database without file path. This approach will prevent incorrect file paths from being saved if they are moved by the user.\par
Another feature we have decided to include is letting the user save sets of parameters values that they commonly use. This feature will be useful to researchers because depending on which sets of parameters are used with sound files, the outcomes of the soundecology indices can produce different types of meaningful results. Users will be able to give a set of parameters an alisas so it can be easily identified, otherwise a name based on the date that date was first used will be assigned. When creating a new job, the user will see the chosen names of all the preset parameters listed for each index or create a new set.\par
A status will also be assigned to each job to inform the user of what is going on. These will include queued, processing, finished and failed. Jobs will be queued if they have not started processing yet. Processing will be assigned to jobs currently running. Finished after the job is complete or failed if an error caused the job to stop processing before it was completed. Users will be able to filter jobs based on this, such as seeing a list of all jobs that are currently processing or all completed jobs.\par
